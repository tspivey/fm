#!/usr/bin/env python3
import sys
import os
from pathlib import Path
import termios
import tty
import struct
import fcntl
import configparser
import subprocess

def readchar():
	old_settings = termios.tcgetattr(sys.stdin.fileno())
	new_settings = list(old_settings)
	tty.cfmakeraw(new_settings)
	try:
		termios.tcsetattr(sys.stdin.fileno(), termios.TCSAFLUSH, new_settings)
		ch = os.read(sys.stdin.fileno(), 10).decode('utf-8')
		return ch
	finally:
		termios.tcsetattr(sys.stdin.fileno(), termios.TCSANOW, old_settings)

def get_terminal_size(fd):
	s = struct.pack('HHHH', 0, 0, 0, 0)
	rows, cols, _, _ = struct.unpack('HHHH', fcntl.ioctl(fd, termios.TIOCGWINSZ, s))
	return rows, cols

class Tab:
	def __init__(self):
		self.files: list[Path] = []
		self.dir = None
		self.cur = 0

	def read_directory(self, dir):
		dir = self.dir = Path(dir).absolute()
		entries = []
		for e in dir.glob('*'):
			entries.append(e)
		self.files = entries
		self.cur = 0

	def sort(self, how):
		reverse = False
		if how == 'name-asc':
			def key(x): return x.name
		elif how == 'name-desc':
			def key(x): return x.name
			reverse = True
		elif how == 'size-asc':
			def key(x): return x.stat(follow_symlinks=False).st_size
		elif how == 'size-desc':
			def key(x): return x.stat(follow_symlinks=False).st_size
			reverse = True
		elif how == 'time-asc':
			def key(x): return x.stat(follow_symlinks=False).st_mtime_ns
		elif how == 'time-desc':
			def key(x): return x.stat(follow_symlinks=False).st_mtime_ns
			reverse = True
		else:
			raise RuntimeError(f"Unknown sort method {how}")
		self.files.sort(key=key, reverse=reverse)

	def focus(self, name):
		for i, f in enumerate(self.files):
			if f.name == name:
				self.cur = i
				return

class FileManager:
	def __init__(self):
		self.current_tab = 0
		self.tabs = [Tab()]
		self.rows, self.cols = get_terminal_size(sys.stdin.fileno())
		self.config = configparser.ConfigParser()

	@property
	def tab(self):
		return self.tabs[self.current_tab]

	def run(self):
		self.display_current_filename()
		while True:
			ch = readchar()
			if ch == 'q':
				self.write('\r\n')
				sys.exit(0)
			elif ch == ' ':
				self.display_current_filename(True)
			elif ch == '\x1b[A':
				self.move_up()
			elif ch == '\x1b[B':
				self.move_down()
			elif ch == 'b':
				self.tab.cur = 0
				print("\r\ntop")
				self.display_current_filename()
			elif ch == '\r':
				self.open_file()
			elif ch == '.':
				self.go_to_parent()
			elif ch == 'g':
				self.go_to_directory()
				self.display_current_filename()

	def display_current_filename(self, full=False):
		self.write('\x1b[2K\r')
		if len(self.tab.files) == 0:
			self.write('Empty directory')
			return
		filename = self.tab.files[self.tab.cur].name
		if self.tab.files[self.tab.cur].is_dir():
			filename += '/'
		if len(filename) > self.cols and not full:
			filename = filename[:self.cols - 1] + "$"
		self.write(filename+'\r')

	def write(self, s):
		sys.stdout.write(s)
		sys.stdout.flush()

	def move_up(self):
		self.tab.cur -= 1
		if self.tab.cur < 0:
			self.tab.cur = 0
		self.display_current_filename()

	def move_down(self):
		self.tab.cur += 1
		if self.tab.cur > len(self.tab.files) - 1:
			self.tab.cur = len(self.tab.files) - 1
		self.display_current_filename()

	def open_file(self):
		if len(self.tab.files) == 0:
			return
		file = self.tab.files[self.tab.cur]
		if file.is_dir():
			self.read_directory(file)
			self.display_current_filename()
			return
		else: # File, run it
			subprocess.call(['run-mailcap', str(file)])
			self.display_current_filename()

	def go_to_parent(self):
		assert self.tab.dir is not None
		if str(self.tab.dir) == '/':
			print("\nAlready at root")
			self.display_current_filename()
			return
		parent = self.tab.dir.parent
		name = self.tab.dir.name
		self.read_directory(parent)
		self.tab.focus(name)
		self.display_current_filename()

	def go_to_directory(self):
		d = input("Go to directory: ")
		if not os.path.isdir(d):
			print("Not a directory")
			return
		self.read_directory(d)

	def read_config(self):
		xdg_config_home = os.environ.get('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))
		config_file = os.path.join(xdg_config_home, 'fm', 'config')
		if not os.path.exists(config_file):
			return
		self.config.read(config_file)
		if 'general' not in self.config:
			self.config.add_section('general')
		if self.config['general'].get('sort') and self.config['general'].get('sort') not in 'name-asc name-desc size-asc size-desc time-asc time-desc'.split():
			print(f"{config_file}: sort must be one of name-asc, name-desc, size-asc, size-desc, time-asc or time-desc.", file=sys.stderr)
			sys.exit(1)

	def read_directory(self, directory):
		if not os.access(directory, os.R_OK):
			print("Warning: directory unreadable, the listing will be empty")
		self.tab.read_directory(directory)
		self.tab.sort(self.config['general'].get('sort', 'name-asc'))

def main():
	m = FileManager()
	m.read_config()
	m.read_directory('.')
	m.run()

if __name__ == '__main__':
	main()
